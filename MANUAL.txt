Manual for A Typist's 65816 Assembler in Forth 
Scot W. Stevenson <scot.stevenson@gmail.com>
First version: 31. May 2015
This version: 13. June 2015 


TL;DR

This is a cross-assembler for the 65816 8/16-bit hybrid CPU. 

  - it is written in modern ANSI-orientated Forth (gforth 0.7).
  - its syntax ("Typist's Assembler Format") is optimized for ten-finger
    typing
  - it has true labels
  - it has a simple, brute-force structure that should make it easy to port
    to other processors

We don't care about stuff like memory footprints or speed because the assembler runs on normal PCs. To get it running, you'll need to start gforth with extra memory.


SERIOUSLY, DUDE, WHY?

Forth is a fantastic language to write assemblers in - 


DUDE, WHAT'S FORTH?

Forth is usually classed with the programming languages, though it's actually more an environment to create tailor-made programming languages in. An introduction to Forth is outside the scope of this document, see https://en.wikipedia.org/wiki/Forth_(programming_language) for general background and "Thinking Forth" by Leo Brodie (http://thinking-forth.sourceforge.net/) for a philosophical discussion. 

Anyway -- people kept telling me Forth was a fantastic language to write assemblers in, so I decided to see if was as easy as they kept saying. First, I wrote a version for the 65c02, A Typist's Assembler for the 65c02 in Forth (https://github.com/scotws/tasm65c02). Using that as a base, I wrote this program for its big brother, the 65816. 


HASN'T THAT BEEN DONE BEFORE?

Actually, no. Though there are lots of great assemblers for the 6502/65c02 out there -- see http://www.6502.org/tools/ for a list -- there are very few for the 65816. Those were not an option, though, because I never liked the standard assembler syntax for the 6502, and I certainly don't like the version for the new modes of the 65816 with the square brackets and what not. As with the first assembler, I was aiming for something that would work well for a ten-finger typist. 


SO LET'S SEE THIS NEW SYNTAX OF YOURS

Like all Forth, we use postfix notation (aka "ass-backwards"). We start with the operand, followed by a special version of the opcode that includes the addressing mode as an addition to to the opcode following a dot. This is the opcode's "tail" (because it would get confusing if we called it "postfix" as well). This way,  

    lda $10       becomes         10 lda.d    

The new opcodes are justified along the space between them and the operand. 
Note we don't have to use "$", "%" or "#" for the number formats because we can use HEX, BINARY, and DECIMAL from normal Forth. The complete list of addressing modes for the 65816 is: 


    MODE                      WDC SYNTAX       TYPIST'S SYNTAX

    implied                   dex                    dex
    accumulator               inc                    inc.a
    immediate                 lda #$00            00 lda.#
    absolute                  lda $1000         1000 lda
    absolute x indexed        lda $1000,x       1000 lda.x
    absolute y indexed        lda $1000,y       1000 lda.y
    absolute indirect         jmp ($1000)       1000 jmp.i
    indexed indirect          jmp ($1000,x)     1000 jmp.xi
    absolute long             jmp $101000     101000 jmp.l    (65816)
    absolute long x indexed   jmp $101000,x   101000 jmp.lx   (65816)
    absolute indirect long    jmp [$1000]       1000 jmp.il   (65816)
    direct page               lda $10             10 lda.d
    direct page x indexed     lda $10,x           10 lda.dx
    direct page y indexed     lda $10,y           10 lda.dy
    direct page indirect      lda ($10)           10 lda.di
    dp indirect x indexed     lda ($10,x)         10 lda.dxi
    dp indirect long          lda [$10]           10 lda.dil  (65816) 
    dp indirect y indexed     lda ($10),y         10 lda.diy  
    dp indirect long y index  lda [$10],y         10 lda.dily (65816)
    relative                  bne $2f00         2f00 bne
    relative long             brl $20f000     20f000 bra.l    (65816)
    stack relative            lda 3,S              3 lda.s    (65816)
    stack rel ind y indexed   lda (3,S),y          3 lda.siy  (65816)
    block move                mvp 0,0            0 0 mvp      (65816) 


Note that the "i" (for "indirect") is put where the parenthesis is in normal notation (compare lda.zxi and lda.ziy). The Branch instruction family is treated differently, because we assume that usually a label will usually be used instead of the actual offset. Immediate addressing has keep the hash sign ("#") because it is a "lower case" special character and we avoid conflicts with the "i" used for indirect mode. An example: 

              LDA #$00                        00 lda.#
              TAX                                tax
    loop1:                        -> loop1
              STA $1000,x                   1000 sta.x
              DEX                                dex
              BNE loop1                    loop1 bne

Like Forth itself, the reverse order takes some getting used to, but works fine with some experience. 


OPCODE SYNONYMS

The Typist's Assembler follows a naming system for opcodes that differs from the normal WDC versions. However, since lots of people are use to the offical version, we provide synonyms: 

        Opcode    WDC         Systematic     Synonym
        hex       Code        version 

        82        BRL         bra.l          brl
        5c        JML         jmp.l          jml
        22        JSL         jsr.l          jsl
        f4        PEA         phe.#          pea
        d4        PEI         phe.di         pei
        62        PER         phe.r          per
        6b        RTL         rts.l          rtl

The use of the systematic names is encouraged, these are just for new users. 


SPECIAL CASES

Where Forth words conflict with the opcodes, we add a dot to the opcode, but leave off the tail in absolute mode. At the moment, that only affects AND in absolute mode: 

        AND $1000  is   1000 and. 

The PER command (push effective relative address) uses the ending .r 

        PER        is        phe.r 

In theory, the branch commands should be given this ending as well, but this would mean change merely for chages' sake. 



EXAMPLES

Included in this package are two larger example files: 

    example.fs - Heavily commented, but won't produce working code if assembled. 
        
    rom.fs - Fewer comments, but will produce a working 8k image that can be tested with a program such as A Crude 65816 Emulator (crude65816, https://github.com/scotws/crude65816 ) when it is done. 


COMMENTS, SPACING, AND MULTIPLE COMMANDS

Since this is Forth, you start out with the complete set of Forth commands you can use in the assembler program. This means that comments are marked by a "\" that comments out everything to the end of the line (the ";" of conventional assemblers), and anything in round brackets is ignored as well.

                00 lda.d   ( this is a comment ) 
                01 sta.d   \ this comment takes out the rest of the line 

Since this is not a normal assembler, but Forth, we can put more than one instructions in one line, though this can make reading the code harder. 

                10 lda.d   1000 sta
                11 lda.d   1001 sta 

                nop nop nop nop nop 

(Of course, if we have lots of instructions that are all the same, we should use Forth to write a macro anyway:

             : n-nops  ( u -- )  0 ?do  nop  loop ; 
             5 n-nops 

Remember to use ?DO instead of just do on an ANSI Forth system such as this one to prevent "0 0" loops that go through the complete number space. Fig-FORTH users don't have this problem.) 

For more on style conventions, see below.


ASSEMBLER COMMANDS

For quick typing, all commands are lower case, but will be listed here in upper case for quicker reference. In keeping with Forth conventions, assembler commands are not prefixed with with a dot -- in Forth, these are words that print something to the screen. 

    ORIGIN ( 65addr -- ) Tells the assembler where to start compilation in the 65816 64k 16-bit address space of a bank (not a 24-bit complete address). This word is required. 

    EMULATION MODE ( -- ) Switch to emulated (8-bit) mode. Encodes the SEC XCE sequence (among other things). Note the assembler starts off with the assumption taht we are in this mode. 

    NATIVE MODE ( -- ) Switch to native (16-bit) mode. Encodes the CLC XCE sequence (among other things).  

    MODE? ( -- f ) Return flag showing the mode the assembler thinks it is in. Emulation mode returns "true", native mode "false". 

    A:8 ( -- ) Switch Accumulator to 8-bit mode. Encodes the SEP $20 sequence. Note that we use a colon in this command because shorter forms such as A8 would run the risk of being interpreted as a hex number. 

    A:16 ( -- ) Switch Accumulator to 16-bit mode. Encodes the REP $20 sequence. Note that the assembler will happily let you try to switch to 16-bits even if you are in emulated mode. 

    XY:8 ( -- ) Switch X and Y to 8-bit mode. Encodes the SEP $10 sequence. 

    XY:16 ( -- ) Swtich X and Y to 16-bit mode. Encodes the REP $10 sequence.

    AXY:8 ( -- ) Switch A, X, and Y to 8-bit mode. Encodes the SEP $30 sequence.

    AXY:16 ( -- ) Switch A, X and Y to 16-bit mode. Encodes the REP $30 sequence. 

    A=8? ( -- f ) Check if Accumulator is in 8-bit mode. This instruction and its variants below are provided to allow assertation of the mode we think should be active. 

    A=16? ( -- f ) Check if Accumulator is in 16-bit mode. 

    XY=8? ( -- f ) Check if X and Y registers are in 8-bit mode. 

    XY=16? ( -- f ) Check if X and Y registers are in 16-bit mode. 

    B, ( u -- ) Store one byte in memory. Note this can be use with Forth LOOPs etc.

    W, ( u -- ) Store one word (16 bit) in memory in correct little-endian format. 

    LW, ( u -- ) Store one long word (24 bit) in memory in correct little-endian format. 

    STR, ( addr u -- ) Store a ASCII string in memory. Use with S" STRING". Note that gforth uses S, so we can't. 

    STR0, (addr u -- ) Store a zero-terminated string in memory. Use with
S" STRING".

    STRLF, (addr u -- ) Store a linefeed-terminated string in memory. Use 
with S" STRING".

    LSB ( u -- u ) returns the least significant byte of a 16-bit number

    MSB ( u -- u ) returns the most significant byte of a 16-bit number

    BANK ( u -- u ) returns the bank byte of a 24-bit number

    ADVANCE ( 65addr -- ) Continue assembly at the address given, filling everything between here and there with zeros.

    END ( -- addr u ) End assembly, returning the address in Forth's memory where the first assembled instruction was saved and the length of the binary file. Use command such as DUMP to print it to the screen. 

    SAVE ( addr u "name" -- ) Following END, save the binary output to the file given. Note this will brutally overwrite existing files without warning. 

We don't need a ".EQU" command -- just use the VALUE built-in Forth command. 



MODE SWITCHES 

The 65816 is a hybrid processor that has an "emulation" mode, where it pretends to be an 8-bit 6502, and a "native" mode, where the A, X, and Y registers can be switched to 16 bits. We start off in emulation mode. To switch modes, use the commands

        EMULATION MODE
or
        NATIVE MODE

These encode the SEC XCE and CLC XCE sequences respectively. You could code these instructions by hand. However, using these built-in commands lets the assembler know which mode it is supposed to be in. 

There is a similiar situation with the size of the Accumulator and X and Y registers. Again, you can code these instuctions by hand with 

                10 rep
or
                20 sep

However, you should not do that, because the assembler needs to know what mode the processor is so it can decide if, say, A9 10 00 should be interpreted as 8-bit instruction sequence 

                10 lda.# 
                   brk 

or the 16-bit variant 

              0010 lda.#  
        
The normal WDC assembler format uses the pseudo-commands LONGA ON/OFF and LONGI ON/OFF to tell this to the assembler. These commands do not generate any code. The Typist's Assembler uses the commands

    A:8   A:16   XY:8   XY:16   AXY:8   AXY:16

that not only encode the REP and SEP sequences, but also make sure that the correct number of operands are assigned to the hybrid opcodes. Therefore, again, it is very important that mode switches are performed by using those commands and not directly with REP and SEP (unless you really, really know what you are doing). 

Compare the example from the WDC manual on page 92 to our version: 

      MACHINE CODE      WDC ASSEMBLER        TYPIST'S ASSEMBLER

         E2 20          SEP #$00100000            a:8 
                        LONGA OFF               
         A9 3F          LDA #$3F               3f lda.# 
      8D 00 B1          STA $B100            b100 sta 

Note the A:8 command automatically takes care of the SEP instruction for us, and also includes the function of the LONGA OFF sequence. 



LABELS, JUMPS AND BRANCHES

(NOTE: CURRENTLY, LONG JUMPS AND BRANCHES DO NOT WORK)

Here's another problem with existing Forth assemblers: A lot of them don't accept labels, especially not forward references. They tell you to suck it up and use "structured programming" instead. Er, no. 

As you can tell from the examples, labels are prefixed with "->" ("-->" would have been easier to read but it's used in ancient Forths as part of the BLOCK commands). Once a label is defined, you can use it for backwards jumps, branches and references without further ado. 
   
   -> frog         nop
              frog bra
              frog jmp

(When choosing a loop label name, remember that LOOP is already taken by Forth itself, as are REPEAT, BEGIN, and AGAIN.) 

Forward branches are a bit more complicated, because internally the assembler has to create a list of unresolved references until the actual location of the label is known (a well-defined problem with single-pass assemblers). We deal with this by putting a special instruction at the start of the lines with forward references: "J>" for jumps (absolute addressing) and "B>" for branches (relative addressing). 

           j> frog jsr 
                   nop

           j> frog jsr 
                   nop

           b> dogs bra
                   nop

   -> dogs         brk 
   -> frog         inc
              dogs bra 
                   rts

Note that by convention, there is one space between the "J>" or "B>" instruction and the label name. After the label has been defined with "->", we can access it without any further hassle. Because of the way forward references are handled, it is easier to deal with strings and subroutines if they are defined before the main code. 

To access the most significant byte of a unresolved address referenced by a
label, we use "MSB>", for the least significant byte we use "LSB>". For example, let's say the subroutine PRTSTR prints a zero-terminated string
with the address in $00 and $01

     lsb> truthstr lda.#   
                00 sta.d
     msb> truthstr lda.#   
                01 sta.d
            prtstr jsr 
                   brk 
   -> truthstr
   s" Cats are cool" str0,

Note we use a variant of STR, here that automatically adds the terminating zero.



STYLE CONVENTIONS

As a very rough guide, labels and Forth code are indented by four spaces: 

   -> cake
   dup 1+ swap nip 

The opcode body starts at 20 spaces in ("middle justified"). This means that the operands are ragged to the left. 

                   nop
              1000 lda.# 
                10 sta.d

As stated, the J> and such instructions are separated by one space from the target (see above). Putting more than one assembler instruction on one line is possible -- this is Forth, after all -- but not encouraged because it can make the code harder to read. If it is done, the convention is to leave three spaces between "blocked" instructions if they have an operand and one if not.

                10 lda.d   1000 sta
                11 lda.d   1001 sta 

                nop nop nop nop nop 

The first instructions are still "middle justified" with the first opcode starting 20 spaces in. 



CALLING THE ASSEMBLER

Start gforth with extra memory, something like 

        gforth -m 1G 

Then, INCLUDE the assembler: 

        include tasm65816.fs

Do the same with your source file, in this case example.fs

        include example.fs

You will be left with ( addr u ) on the stack, describing the beginning of the machine code and the number of bytes in it. 


ANYTHING ELSE?

The assembler uses single, unsorted linked lists to deal with unresolved forward references. Use the following routine to print the contents of these list during debugging. 

\ Print entries in simple linked list when given xt of list
: dumplabellist ( xt -- ) 
   >body
   begin
      dup
   while
      dup cell+ @ .       \ print data
      dup 2 cells +  @    \ print type of link
          if ." (jump) " else ." (branch) " then
      @
   repeat
   drop ; 
 

LEGAL STUFF

A Typist's 65816 Assembler in Forth is released under the GNU Public License, see LICENSE. Use this software at your own risk. 


LINKS 

- For all things to do with the 6502/65c02/65816, see http://www.6502.org/
  Very nice, very helpful people. 

- Brad Rodriguez has published a series of articles on how to write your own assembler in Forth which were invaluable for this project. See those and other writings on Forth at http://www.bradrodriguez.com/papers/

- Backgrounder book: "Assemblers And Loaders" by David Salomon (1993). Available as free PDF from http://www.davidsalomon.name/assem.advertis/AssemAd.html
