Technical Info for A Typist's 65816 Assembler in Forth 
Scot W. Stevenson <scot.stevenson@gmail.com>
First version: 02. July 2015
This version: 02. July 2015


THIS FILE IS INCOMPLETE

This text contains additional information on the internals of the Typist's Assembler for the 65816 in Forth. It is not required to use the software, and is horribly geeky. 



FUTURE REFERENCES

Single-pass assemblers are actually pretty easy to write -- except for the part with the unresolved symbols, "future references". Since the Forth compiler has no way of knowing that you are defining a new label, it will throw an error when it comes across a line such as

        gothere jmp 

Future references are a real pain -- if you take a look at the source code of the assembler, you can see how much space these routines take. 

The Typist's Assembler started out as a 6502 version with different label directives for branches and jumps to solve this problem:

        j>      absolute forward reference
        b>      relative forward reference

For example, in the following instruction

        j> gothere jmp

the label directive starts a linked list of unresolved references to "gothere", remembers the offset where the two-byte operand has to be saved (BC+1) in the linked list, and then stores there a link to the Forth word is used to insert the correct address later. A zero is pushed on the stack as a dummy address, and JMP simply assembles its own opcode ($4C) and the two bytes of the dummy address in little-endian format. It knows nothing about future or past references.

(Why a dummy value of zero? This allows easy math with the label, for example

        j> gothere 1+ jmp

to jump one byte past the label.) 

However, this became unwieldy with the 65816, because you need long branches and long jumps as well -- you end up with

        j> jl> b> bl> 

It was also unelegant, because the instruction

        jl> gothere jmp.l

contains the same information about the mode twice, once in the label directive and once in the instruction. 

To avoid this, a single future reference directive was introduced:

        <? gothere jmp.l

(Having the directive pointing to the left seemed to make more sense since the label directive "->" points to the right.) This is a lot nicer, but produces one big problem: We need to know how may bytes to reserve for the operand.

        1 byte:  BRA
        2 bytes: BRA.L, JMP, JSR
        3 bytes: JMP.L, JSR.L 

Worse: If we want to use labels for more than just branching, we need to include instructions such as LDA.L, STA.X etc as well. 

In theory, we could have <? parse the input stream to find the next opcode to retrieve this information. However, as the Gforth manual states: "It should be obvious by now that parsing words are a bad idea." 

Instead, we make instructions themselves aware that they are dealing with a reference to an as of yet undefined label. The mechanism is the flag FUTURECALL that is set by the <? directive: If it is the default clear (zero), than we are not dealing with a future reference and we can just assemble the word normally. Our JMP instruction merely saves the opcode and the two bytes of the address.

However, if we do have a future reference, we create a new entry in a linked list for this label (ADDLABEL). We save three things in each list entry: The address of the previous entry (or zero to mark the tail of the list); an offset to the beginning of the staging area where we are assembling the code, so we know where to put the operand; and an execution token (xt) to the Forth word that this type of instruction needs complete the operand later.

It is this location of the "slot" for the execution token that <? stores in FUTURECALL. Since this produces a non-zero flag, the instrutions know that they are involved in a future reference, and also know where to store their xt. In pseudocode, we are looking at something like this for an instructions such as JMP:

        : jmp ( addr|dummy -- ) 
            futurecall? if
                <SAVE XT FOR JMP IN LINKED LIST>
                <CLEAR FUTURECALL FLAG>
            then
            4c b,       \ assemble opcode
            lw, ;       \ store 16-bit address/dummy little-endian

Notice that <? also pushes a zero to the stack so that we can still do address math even before we know the currect address. 

A branching call works a bit diffently, because it calculates the offset, not the absolute ddres. 

        : bra ( addr|dummy -- ) 
            futurecall? if
                <SAVE XT FOR BRA IN LINKED LIST>
                <CLEAR FUTURECALL FLAG>
                drop lc  \ replace dummy zero by current location
            then
            <CALCULATE OFFSET>
            80 b,       \ assemble opcode
            b, ;        \ store 8-bit offset

Note that the branch instructions assume that they are being fed a label or an absolute address, not an offset. 

We can factor a large part of this out. 
                






 

